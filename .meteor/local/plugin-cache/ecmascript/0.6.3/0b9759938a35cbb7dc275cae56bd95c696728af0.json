{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/modify.js","filenameRelative":"/packages/minimongo/modify.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/modify.js.map","sourceFileName":"/packages/minimongo/modify.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"modify"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = function (doc, mod, options) {\n  options = options || {};\n  if (!isPlainObject(mod)) throw MinimongoError(\"Modifier must be an object\"); // Make sure the caller can't mutate our data structures.\n\n  mod = EJSON.clone(mod);\n  var isModifier = isOperatorObject(mod);\n  var newDoc;\n\n  if (!isModifier) {\n    if (mod._id && !EJSON.equals(doc._id, mod._id)) throw MinimongoError(\"Cannot change the _id of a document\"); // replace the whole document\n\n    for (var k in meteorBabelHelpers.sanitizeForInObject(mod)) {\n      if (/\\./.test(k)) throw MinimongoError(\"When replacing document, field name may not contain '.'\");\n    }\n\n    newDoc = mod;\n  } else {\n    // apply modifiers to the doc.\n    newDoc = EJSON.clone(doc);\n\n    _.each(mod, function (operand, op) {\n      var modFunc = MODIFIERS[op]; // Treat $setOnInsert as $set if this is an insert.\n\n      if (options.isInsert && op === '$setOnInsert') modFunc = MODIFIERS['$set'];\n      if (!modFunc) throw MinimongoError(\"Invalid modifier specified \" + op);\n\n      _.each(operand, function (arg, keypath) {\n        if (keypath === '') {\n          throw MinimongoError(\"An empty update path is not valid.\");\n        }\n\n        if (keypath === '_id' && op !== '$setOnInsert') {\n          throw MinimongoError(\"Mod on _id not allowed\");\n        }\n\n        var keyparts = keypath.split('.');\n\n        if (!_.all(keyparts, _.identity)) {\n          throw MinimongoError(\"The update path '\" + keypath + \"' contains an empty field name, which is not allowed.\");\n        }\n\n        var noCreate = _.has(NO_CREATE_MODIFIERS, op);\n\n        var forbidArray = op === \"$rename\";\n        var target = findModTarget(newDoc, keyparts, {\n          noCreate: NO_CREATE_MODIFIERS[op],\n          forbidArray: op === \"$rename\",\n          arrayIndices: options.arrayIndices\n        });\n        var field = keyparts.pop();\n        modFunc(target, field, arg, keypath, newDoc);\n      });\n    });\n  } // move new document into place.\n\n\n  _.each(_.keys(doc), function (k) {\n    // Note: this used to be for (var k in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (k !== '_id') delete doc[k];\n  });\n\n  _.each(newDoc, function (v, k) {\n    doc[k] = v;\n  });\n}; // for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\n\n\nvar findModTarget = function (doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n\n    if (!indexable) {\n      if (options.noCreate) return undefined;\n      var e = MinimongoError(\"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) return null;\n\n      if (keypart === '$') {\n        if (usedArrayIndex) throw MinimongoError(\"Too many positional (i.e. '$') elements\");\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\"The positional operator did not find the \" + \"match needed from the query\");\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) return undefined;\n        throw MinimongoError(\"can't append to array using string field name [\" + keypart + \"]\");\n      }\n\n      if (last) // handle 'a.01'\n        keyparts[i] = keypart;\n      if (options.noCreate && keypart >= doc.length) return undefined;\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) doc.push({});else if ((0, _typeof3.default)(doc[keypart]) !== \"object\") throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] + \"' of list value \" + JSON.stringify(doc[keypart]));\n      }\n    } else {\n      if (keypart.length && keypart.substr(0, 1) === '$') throw MinimongoError(\"can't set field named \" + keypart);\n\n      if (!(keypart in doc)) {\n        if (options.noCreate) return undefined;\n        if (!last) doc[keypart] = {};\n      }\n    }\n\n    if (last) return doc;\n    doc = doc[keypart];\n  } // notreached\n\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\nvar MODIFIERS = {\n  $currentDate: function (target, field, arg) {\n    if ((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && arg.hasOwnProperty(\"$type\")) {\n      if (arg.$type !== \"date\") {\n        throw MinimongoError(\"Minimongo does currently only support the date type in $currentDate modifiers\");\n      }\n    } else if (arg !== true) {\n      throw MinimongoError(\"Invalid $currentDate modifier\");\n    }\n\n    target[field] = new Date();\n  },\n  $min: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $min allowed for numbers only\");\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\"Cannot apply $min modifier to non-number\");\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $max allowed for numbers only\");\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\"Cannot apply $max modifier to non-number\");\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function (target, field, arg) {\n    if (typeof arg !== \"number\") throw MinimongoError(\"Modifier $inc allowed for numbers only\");\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") throw MinimongoError(\"Cannot apply $inc modifier to non-number\");\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function (target, field, arg) {\n    if (!_.isObject(target)) {\n      // not an array or an object\n      var e = MinimongoError(\"Cannot set property on non-object field\");\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (target === null) {\n      var e = MinimongoError(\"Cannot set property on null\");\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (_.isString(field) && field.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\"Key \" + field + \" must not contain null bytes\");\n    }\n\n    target[field] = arg;\n  },\n  $setOnInsert: function (target, field, arg) {// converted to `$set` in `_modify`\n  },\n  $unset: function (target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) target[field] = null;\n      } else delete target[field];\n    }\n  },\n  $push: function (target, field, arg) {\n    if (target[field] === undefined) target[field] = [];\n    if (!(target[field] instanceof Array)) throw MinimongoError(\"Cannot apply $push modifier to non-array\");\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      target[field].push(arg);\n      return;\n    } // Fancy mode: $each (and maybe $slice and $sort and $position)\n\n\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) throw MinimongoError(\"$each must be an array\"); // Parse $position\n\n    var position = undefined;\n\n    if ('$position' in arg) {\n      if (typeof arg.$position !== \"number\") throw MinimongoError(\"$position must be a numeric value\"); // XXX should check to make sure integer\n\n      if (arg.$position < 0) throw MinimongoError(\"$position in $push must be zero or positive\");\n      position = arg.$position;\n    } // Parse $slice.\n\n\n    var slice = undefined;\n\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== \"number\") throw MinimongoError(\"$slice must be a numeric value\"); // XXX should check to make sure integer\n\n      if (arg.$slice > 0) throw MinimongoError(\"$slice in $push must be zero or negative\");\n      slice = arg.$slice;\n    } // Parse $sort.\n\n\n    var sortFunction = undefined;\n\n    if (arg.$sort) {\n      if (slice === undefined) throw MinimongoError(\"$sort requires $slice to be present\"); // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n\n      for (var i = 0; i < toPush.length; i++) {\n        if (LocalCollection._f._type(toPush[i]) !== 3) {\n          throw MinimongoError(\"$push like modifiers using $sort \" + \"require all elements to be objects\");\n        }\n      }\n    } // Actually push.\n\n\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++) {\n        target[field].push(toPush[j]);\n      }\n    } else {\n      var spliceArguments = [position, 0];\n\n      for (var j = 0; j < toPush.length; j++) {\n        spliceArguments.push(toPush[j]);\n      }\n\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    } // Actually sort.\n\n\n    if (sortFunction) target[field].sort(sortFunction); // Actually slice.\n\n    if (slice !== undefined) {\n      if (slice === 0) target[field] = []; // differs from Array.slice!\n      else target[field] = target[field].slice(slice);\n    }\n  },\n  $pushAll: function (target, field, arg) {\n    if (!((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && arg instanceof Array)) throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    var x = target[field];\n    if (x === undefined) target[field] = arg;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pushAll modifier to non-array\");else {\n      for (var i = 0; i < arg.length; i++) {\n        x.push(arg[i]);\n      }\n    }\n  },\n  $addToSet: function (target, field, arg) {\n    var isEach = false;\n\n    if ((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\") {\n      //check if first key is '$each'\n      for (var k in meteorBabelHelpers.sanitizeForInObject(arg)) {\n        if (k === \"$each\") isEach = true;\n        break;\n      }\n    }\n\n    var values = isEach ? arg[\"$each\"] : [arg];\n    var x = target[field];\n    if (x === undefined) target[field] = values;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $addToSet modifier to non-array\");else {\n      _.each(values, function (value) {\n        for (var i = 0; i < x.length; i++) {\n          if (LocalCollection._f._equal(value, x[i])) return;\n        }\n\n        x.push(value);\n      });\n    }\n  },\n  $pop: function (target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pop modifier to non-array\");else {\n      if (typeof arg === 'number' && arg < 0) x.splice(0, 1);else x.pop();\n    }\n  },\n  $pull: function (target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");else {\n      var out = [];\n\n      if (arg != null && (typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && !(arg instanceof Array)) {\n        // XXX would be much nicer to compile this once, rather than\n        // for each document we modify.. but usually we're not\n        // modifying that many documents, so we'll let it slide for\n        // now\n        // XXX Minimongo.Matcher isn't up for the job, because we need\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n        // like {$gt: 4} is not normally a complete selector.\n        // same issue as $elemMatch possibly?\n        var matcher = new Minimongo.Matcher(arg);\n\n        for (var i = 0; i < x.length; i++) {\n          if (!matcher.documentMatches(x[i]).result) out.push(x[i]);\n        }\n      } else {\n        for (var i = 0; i < x.length; i++) {\n          if (!LocalCollection._f._equal(x[i], arg)) out.push(x[i]);\n        }\n      }\n\n      target[field] = out;\n    }\n  },\n  $pullAll: function (target, field, arg) {\n    if (!((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && arg instanceof Array)) throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");else {\n      var out = [];\n\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n\n        for (var j = 0; j < arg.length; j++) {\n          if (LocalCollection._f._equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n\n        if (!exclude) out.push(x[i]);\n      }\n\n      target[field] = out;\n    }\n  },\n  $rename: function (target, field, arg, keypath, doc) {\n    if (keypath === arg) // no idea why mongo has this restriction..\n      throw MinimongoError(\"$rename source must differ from target\");\n    if (target === null) throw MinimongoError(\"$rename source field invalid\");\n    if (typeof arg !== \"string\") throw MinimongoError(\"$rename target must be a string\");\n\n    if (arg.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\"The 'to' field for $rename cannot contain an embedded null byte\");\n    }\n\n    if (target === undefined) return;\n    var v = target[field];\n    delete target[field];\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {\n      forbidArray: true\n    });\n    if (target2 === null) throw MinimongoError(\"$rename target field invalid\");\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function (target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError(\"$bit is not supported\");\n  }\n};","ast":null,"map":{"version":3,"sources":["/packages/minimongo/modify.js"],"names":["LocalCollection","_modify","doc","mod","options","isPlainObject","MinimongoError","EJSON","clone","isModifier","isOperatorObject","newDoc","_id","equals","k","test","_","each","operand","op","modFunc","MODIFIERS","isInsert","arg","keypath","keyparts","split","all","identity","noCreate","has","NO_CREATE_MODIFIERS","forbidArray","target","findModTarget","arrayIndices","field","pop","keys","v","usedArrayIndex","i","length","last","keypart","indexable","isIndexable","undefined","e","setPropertyError","Array","isNumericKey","parseInt","push","JSON","stringify","substr","$unset","$pop","$rename","$pull","$pullAll","$currentDate","hasOwnProperty","$type","Date","$min","$max","$inc","$set","isObject","isString","indexOf","$setOnInsert","$push","$each","toPush","position","$position","slice","$slice","sortFunction","$sort","Minimongo","Sorter","getComparator","_f","_type","j","spliceArguments","prototype","splice","apply","sort","$pushAll","x","$addToSet","isEach","values","value","_equal","out","matcher","Matcher","documentMatches","result","exclude","target2","field2","$bit"],"mappings":"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","file":"/packages/minimongo/modify.js.map","sourcesContent":["// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = function (doc, mod, options) {\n  options = options || {};\n  if (!isPlainObject(mod))\n    throw MinimongoError(\"Modifier must be an object\");\n\n  // Make sure the caller can't mutate our data structures.\n  mod = EJSON.clone(mod);\n\n  var isModifier = isOperatorObject(mod);\n\n  var newDoc;\n\n  if (!isModifier) {\n    if (mod._id && !EJSON.equals(doc._id, mod._id))\n      throw MinimongoError(\"Cannot change the _id of a document\");\n\n    // replace the whole document\n    for (var k in mod) {\n      if (/\\./.test(k))\n        throw MinimongoError(\n          \"When replacing document, field name may not contain '.'\");\n    }\n    newDoc = mod;\n  } else {\n    // apply modifiers to the doc.\n    newDoc = EJSON.clone(doc);\n\n    _.each(mod, function (operand, op) {\n      var modFunc = MODIFIERS[op];\n      // Treat $setOnInsert as $set if this is an insert.\n      if (options.isInsert && op === '$setOnInsert')\n        modFunc = MODIFIERS['$set'];\n      if (!modFunc)\n        throw MinimongoError(\"Invalid modifier specified \" + op);\n      _.each(operand, function (arg, keypath) {\n        if (keypath === '') {\n          throw MinimongoError(\"An empty update path is not valid.\");\n        }\n\n        if (keypath === '_id' && op !== '$setOnInsert') {\n          throw MinimongoError(\"Mod on _id not allowed\");\n        }\n\n        var keyparts = keypath.split('.');\n\n        if (! _.all(keyparts, _.identity)) {\n          throw MinimongoError(\n            \"The update path '\" + keypath +\n              \"' contains an empty field name, which is not allowed.\");\n        }\n\n        var noCreate = _.has(NO_CREATE_MODIFIERS, op);\n        var forbidArray = (op === \"$rename\");\n        var target = findModTarget(newDoc, keyparts, {\n          noCreate: NO_CREATE_MODIFIERS[op],\n          forbidArray: (op === \"$rename\"),\n          arrayIndices: options.arrayIndices\n        });\n        var field = keyparts.pop();\n        modFunc(target, field, arg, keypath, newDoc);\n      });\n    });\n  }\n\n  // move new document into place.\n  _.each(_.keys(doc), function (k) {\n    // Note: this used to be for (var k in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (k !== '_id')\n      delete doc[k];\n  });\n  _.each(newDoc, function (v, k) {\n    doc[k] = v;\n  });\n};\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nvar findModTarget = function (doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = (i === keyparts.length - 1);\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n    if (!indexable) {\n      if (options.noCreate)\n        return undefined;\n      var e = MinimongoError(\n        \"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (doc instanceof Array) {\n      if (options.forbidArray)\n        return null;\n      if (keypart === '$') {\n        if (usedArrayIndex)\n          throw MinimongoError(\"Too many positional (i.e. '$') elements\");\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\"The positional operator did not find the \" +\n                               \"match needed from the query\");\n        }\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate)\n          return undefined;\n        throw MinimongoError(\n          \"can't append to array using string field name [\"\n                    + keypart + \"]\");\n      }\n      if (last)\n        // handle 'a.01'\n        keyparts[i] = keypart;\n      if (options.noCreate && keypart >= doc.length)\n        return undefined;\n      while (doc.length < keypart)\n        doc.push(null);\n      if (!last) {\n        if (doc.length === keypart)\n          doc.push({});\n        else if (typeof doc[keypart] !== \"object\")\n          throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] +\n                      \"' of list value \" + JSON.stringify(doc[keypart]));\n      }\n    } else {\n      if (keypart.length && keypart.substr(0, 1) === '$')\n        throw MinimongoError(\"can't set field named \" + keypart);\n      if (!(keypart in doc)) {\n        if (options.noCreate)\n          return undefined;\n        if (!last)\n          doc[keypart] = {};\n      }\n    }\n\n    if (last)\n      return doc;\n    doc = doc[keypart];\n  }\n\n  // notreached\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\n\nvar MODIFIERS = {\n  $currentDate: function (target, field, arg) {\n    if (typeof arg === \"object\" && arg.hasOwnProperty(\"$type\")) {\n       if (arg.$type !== \"date\") {\n         throw MinimongoError(\"Minimongo does currently only support the date type in $currentDate modifiers\");\n       }\n    } else if (arg !== true) {\n      throw MinimongoError(\"Invalid $currentDate modifier\");\n    }\n    target[field] = new Date();\n  },\n  $min: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $min allowed for numbers only\");\n    }\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\"Cannot apply $min modifier to non-number\");\n      }\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $max allowed for numbers only\");\n    }\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\"Cannot apply $max modifier to non-number\");\n      }\n      if (target[field] < arg) {\n         target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function (target, field, arg) {\n    if (typeof arg !== \"number\")\n      throw MinimongoError(\"Modifier $inc allowed for numbers only\");\n    if (field in target) {\n      if (typeof target[field] !== \"number\")\n        throw MinimongoError(\"Cannot apply $inc modifier to non-number\");\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function (target, field, arg) {\n    if (!_.isObject(target)) { // not an array or an object\n      var e = MinimongoError(\"Cannot set property on non-object field\");\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (target === null) {\n      var e = MinimongoError(\"Cannot set property on null\");\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (_.isString(field) && field.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(`Key ${field} must not contain null bytes`);\n    }\n    target[field] = arg;\n  },\n  $setOnInsert: function (target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset: function (target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target)\n          target[field] = null;\n      } else\n        delete target[field];\n    }\n  },\n  $push: function (target, field, arg) {\n    if (target[field] === undefined)\n      target[field] = [];\n    if (!(target[field] instanceof Array))\n      throw MinimongoError(\"Cannot apply $push modifier to non-array\");\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      target[field].push(arg);\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array))\n      throw MinimongoError(\"$each must be an array\");\n\n    // Parse $position\n    var position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== \"number\")\n        throw MinimongoError(\"$position must be a numeric value\");\n      // XXX should check to make sure integer\n      if (arg.$position < 0)\n        throw MinimongoError(\"$position in $push must be zero or positive\");\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    var slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== \"number\")\n        throw MinimongoError(\"$slice must be a numeric value\");\n      // XXX should check to make sure integer\n      if (arg.$slice > 0)\n        throw MinimongoError(\"$slice in $push must be zero or negative\");\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    var sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined)\n        throw MinimongoError(\"$sort requires $slice to be present\");\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      for (var i = 0; i < toPush.length; i++) {\n        if (LocalCollection._f._type(toPush[i]) !== 3) {\n          throw MinimongoError(\"$push like modifiers using $sort \" +\n                      \"require all elements to be objects\");\n        }\n      }\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++)\n        target[field].push(toPush[j]);\n    } else {\n      var spliceArguments = [position, 0];\n      for (var j = 0; j < toPush.length; j++)\n        spliceArguments.push(toPush[j]);\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction)\n      target[field].sort(sortFunction);\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0)\n        target[field] = [];  // differs from Array.slice!\n      else\n        target[field] = target[field].slice(slice);\n    }\n  },\n  $pushAll: function (target, field, arg) {\n    if (!(typeof arg === \"object\" && arg instanceof Array))\n      throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    var x = target[field];\n    if (x === undefined)\n      target[field] = arg;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\"Cannot apply $pushAll modifier to non-array\");\n    else {\n      for (var i = 0; i < arg.length; i++)\n        x.push(arg[i]);\n    }\n  },\n  $addToSet: function (target, field, arg) {\n    var isEach = false;\n    if (typeof arg === \"object\") {\n      //check if first key is '$each'\n      for (var k in arg) {\n        if (k === \"$each\")\n          isEach = true;\n        break;\n      }\n    }\n    var values = isEach ? arg[\"$each\"] : [arg];\n    var x = target[field];\n    if (x === undefined)\n      target[field] = values;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\"Cannot apply $addToSet modifier to non-array\");\n    else {\n      _.each(values, function (value) {\n        for (var i = 0; i < x.length; i++)\n          if (LocalCollection._f._equal(value, x[i]))\n            return;\n        x.push(value);\n      });\n    }\n  },\n  $pop: function (target, field, arg) {\n    if (target === undefined)\n      return;\n    var x = target[field];\n    if (x === undefined)\n      return;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\"Cannot apply $pop modifier to non-array\");\n    else {\n      if (typeof arg === 'number' && arg < 0)\n        x.splice(0, 1);\n      else\n        x.pop();\n    }\n  },\n  $pull: function (target, field, arg) {\n    if (target === undefined)\n      return;\n    var x = target[field];\n    if (x === undefined)\n      return;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");\n    else {\n      var out = [];\n      if (arg != null && typeof arg === \"object\" && !(arg instanceof Array)) {\n        // XXX would be much nicer to compile this once, rather than\n        // for each document we modify.. but usually we're not\n        // modifying that many documents, so we'll let it slide for\n        // now\n\n        // XXX Minimongo.Matcher isn't up for the job, because we need\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n        // like {$gt: 4} is not normally a complete selector.\n        // same issue as $elemMatch possibly?\n        var matcher = new Minimongo.Matcher(arg);\n        for (var i = 0; i < x.length; i++)\n          if (!matcher.documentMatches(x[i]).result)\n            out.push(x[i]);\n      } else {\n        for (var i = 0; i < x.length; i++)\n          if (!LocalCollection._f._equal(x[i], arg))\n            out.push(x[i]);\n      }\n      target[field] = out;\n    }\n  },\n  $pullAll: function (target, field, arg) {\n    if (!(typeof arg === \"object\" && arg instanceof Array))\n      throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    if (target === undefined)\n      return;\n    var x = target[field];\n    if (x === undefined)\n      return;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\");\n    else {\n      var out = [];\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n        for (var j = 0; j < arg.length; j++) {\n          if (LocalCollection._f._equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n        if (!exclude)\n          out.push(x[i]);\n      }\n      target[field] = out;\n    }\n  },\n  $rename: function (target, field, arg, keypath, doc) {\n    if (keypath === arg)\n      // no idea why mongo has this restriction..\n      throw MinimongoError(\"$rename source must differ from target\");\n    if (target === null)\n      throw MinimongoError(\"$rename source field invalid\");\n    if (typeof arg !== \"string\")\n      throw MinimongoError(\"$rename target must be a string\");\n    if (arg.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\"The 'to' field for $rename cannot contain an embedded null byte\");\n    }\n    if (target === undefined)\n      return;\n    var v = target[field];\n    delete target[field];\n\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {forbidArray: true});\n    if (target2 === null)\n      throw MinimongoError(\"$rename target field invalid\");\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function (target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError(\"$bit is not supported\");\n  }\n};\n"]},"hash":"0b9759938a35cbb7dc275cae56bd95c696728af0"}
