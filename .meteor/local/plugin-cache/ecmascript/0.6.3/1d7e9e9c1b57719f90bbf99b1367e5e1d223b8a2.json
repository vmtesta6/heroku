{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/minimongo.js","filenameRelative":"/packages/minimongo/minimongo.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/minimongo.js.map","sourceFileName":"/packages/minimongo/minimongo.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"minimongo"},"ignored":false,"code":"// XXX type checking on selectors (graceful error if malformed)\n// LocalCollection: a set of documents that supports queries and modifiers.\n// Cursor: a specification for a particular subset of documents, w/\n// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),\n// ObserveHandle: the return value of a live query.\nLocalCollection = function (name) {\n  var self = this;\n  self.name = name; // _id -> document (also containing id)\n\n  self._docs = new LocalCollection._IdMap();\n  self._observeQueue = new Meteor._SynchronousQueue();\n  self.next_qid = 1; // live query id generator\n  // qid -> live query object. keys:\n  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n  //  results: array (ordered) or object (unordered) of current results\n  //    (aliased with self._docs!)\n  //  resultsSnapshot: snapshot of results. null if not paused.\n  //  cursor: Cursor object for the query.\n  //  selector, sorter, (callbacks): functions\n\n  self.queries = {}; // null if not saving originals; an IdMap from id to original document value if\n  // saving originals. See comments before saveOriginals().\n\n  self._savedOriginals = null; // True when observers are paused and we should not send callbacks.\n\n  self.paused = false;\n};\n\nMinimongo = {}; // Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\n\nMinimongoTest = {};\n\nMinimongoError = function (message) {\n  var e = new Error(message);\n  e.name = \"MinimongoError\";\n  return e;\n}; // options may include sort, skip, limit, reactive\n// sort may be any of these forms:\n//     {a: 1, b: -1}\n//     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n//     [\"a\", [\"b\", \"desc\"]]\n//   (in the first form you're beholden to key enumeration order in\n//   your javascript VM)\n//\n// reactive: if given, and false, don't register with Tracker (default\n// is true)\n//\n// XXX possibly should support retrieving a subset of fields? and\n// have it be a hint (ignored on the client, when not copying the\n// doc?)\n//\n// XXX sort does not yet support subkeys ('a.b') .. fix that!\n// XXX add one more sort form: \"key\"\n// XXX tests\n\n\nLocalCollection.prototype.find = function (selector, options) {\n  // default syntax for everything is to omit the selector argument.\n  // but if selector is explicitly passed in as false or undefined, we\n  // want a selector that matches nothing.\n  if (arguments.length === 0) selector = {};\n  return new LocalCollection.Cursor(this, selector, options);\n}; // don't call this ctor directly.  use LocalCollection.find().\n\n\nLocalCollection.Cursor = function (collection, selector, options) {\n  var self = this;\n  if (!options) options = {};\n  self.collection = collection;\n  self.sorter = null;\n  self.matcher = new Minimongo.Matcher(selector);\n\n  if (LocalCollection._selectorIsId(selector)) {\n    // stash for fast path\n    self._selectorId = selector;\n  } else if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    // also do the fast path for { _id: idString }\n    self._selectorId = selector._id;\n  } else {\n    self._selectorId = undefined;\n\n    if (self.matcher.hasGeoQuery() || options.sort) {\n      self.sorter = new Minimongo.Sorter(options.sort || [], {\n        matcher: self.matcher\n      });\n    }\n  }\n\n  self.skip = options.skip;\n  self.limit = options.limit;\n  self.fields = options.fields;\n  self._projectionFn = LocalCollection._compileProjection(self.fields || {});\n  self._transform = LocalCollection.wrapTransform(options.transform); // by default, queries register w/ Tracker when it is available.\n\n  if (typeof Tracker !== \"undefined\") self.reactive = options.reactive === undefined ? true : options.reactive;\n}; // Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\n\n\nLocalCollection.Cursor.prototype.rewind = function () {};\n\nLocalCollection.prototype.findOne = function (selector, options) {\n  if (arguments.length === 0) selector = {}; // NOTE: by setting limit 1 here, we end up using very inefficient\n  // code that recomputes the whole query on each update. The upside is\n  // that when you reactively depend on a findOne you only get\n  // invalidated when the found object changes, not any object in the\n  // collection. Most findOne will be by id, which has a fast path, so\n  // this might not be a big deal. In most cases, invalidation causes\n  // the called to re-query anyway, so this should be a net performance\n  // improvement.\n\n  options = options || {};\n  options.limit = 1;\n  return this.find(selector, options).fetch()[0];\n}; /**\n    * @callback IterationCallback\n    * @param {Object} doc\n    * @param {Number} index\n    */ /**\n        * @summary Call `callback` once for each matching document, sequentially and synchronously.\n        * @locus Anywhere\n        * @method  forEach\n        * @instance\n        * @memberOf Mongo.Cursor\n        * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n        * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n        */\n\nLocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {\n  var self = this;\n\n  var objects = self._getRawObjects({\n    ordered: true\n  });\n\n  if (self.reactive) {\n    self._depend({\n      addedBefore: true,\n      removed: true,\n      changed: true,\n      movedBefore: true\n    });\n  }\n\n  _.each(objects, function (elt, i) {\n    // This doubles as a clone operation.\n    elt = self._projectionFn(elt);\n    if (self._transform) elt = self._transform(elt);\n    callback.call(thisArg, elt, i, self);\n  });\n};\n\nLocalCollection.Cursor.prototype.getTransform = function () {\n  return this._transform;\n}; /**\n    * @summary Map callback over all matching documents.  Returns an Array.\n    * @locus Anywhere\n    * @method map\n    * @instance\n    * @memberOf Mongo.Cursor\n    * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n    * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n    */\n\nLocalCollection.Cursor.prototype.map = function (callback, thisArg) {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc, index) {\n    res.push(callback.call(thisArg, doc, index, self));\n  });\n  return res;\n}; /**\n    * @summary Return all matching documents as an Array.\n    * @memberOf Mongo.Cursor\n    * @method  fetch\n    * @instance\n    * @locus Anywhere\n    * @returns {Object[]}\n    */\n\nLocalCollection.Cursor.prototype.fetch = function () {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc) {\n    res.push(doc);\n  });\n  return res;\n}; /**\n    * @summary Returns the number of documents that match a query.\n    * @memberOf Mongo.Cursor\n    * @method  count\n    * @instance\n    * @locus Anywhere\n    * @returns {Number}\n    */\n\nLocalCollection.Cursor.prototype.count = function () {\n  var self = this;\n  if (self.reactive) self._depend({\n    added: true,\n    removed: true\n  }, true /* allow the observe to be unordered */);\n  return self._getRawObjects({\n    ordered: true\n  }).length;\n};\n\nLocalCollection.Cursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  if (!self.collection.name) throw new Error(\"Can't publish a cursor from a collection without a name.\");\n  var collection = self.collection.name; // XXX minimongo should not depend on mongo-livedata!\n\n  if (!Package.mongo) {\n    throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");\n  }\n\n  return Package.mongo.Mongo.Collection._publishCursor(self, sub, collection);\n};\n\nLocalCollection.Cursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self.collection.name;\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedBefore) throw new Error(\"Please specify only one of added() and addedBefore()\");\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.addedAt && callbacks.added) throw new Error(\"Please specify only one of added() and addedAt()\");\n  if (callbacks.changedAt && callbacks.changed) throw new Error(\"Please specify only one of changed() and changedAt()\");\n  if (callbacks.removed && callbacks.removedAt) throw new Error(\"Please specify only one of removed() and removedAt()\");\n  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt || callbacks.removedAt);\n}; // the handle that comes back from observe.\n\n\nLocalCollection.ObserveHandle = function () {}; // options to contain:\n//  * callbacks for observe():\n//    - addedAt (document, atIndex)\n//    - added (document)\n//    - changedAt (newDocument, oldDocument, atIndex)\n//    - changed (newDocument, oldDocument)\n//    - removedAt (document, atIndex)\n//    - removed (document)\n//    - movedTo (document, oldIndex, newIndex)\n//\n// attributes available on returned query handle:\n//  * stop(): end updates\n//  * collection: the collection this query is querying\n//\n// iff x is a returned query handle, (x instanceof\n// LocalCollection.ObserveHandle) is true\n//\n// initial results delivered through added callback\n// XXX maybe callbacks should take a list of objects, to expose transactions?\n// XXX maybe support field limiting (to limit what you're notified on)\n\n\n_.extend(LocalCollection.Cursor.prototype, {\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */observe: function (options) {\n    var self = this;\n    return LocalCollection._observeFromObserveChanges(self, options);\n  },\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.  Only the differences between the old and new documents are passed to the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */observeChanges: function (options) {\n    var self = this;\n\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options); // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n\n\n    if (!options._allow_unordered && !ordered && (self.skip || self.limit)) throw new Error(\"must use ordered observe (ie, 'addedBefore' instead of 'added') with skip or limit\");\n    if (self.fields && (self.fields._id === 0 || self.fields._id === false)) throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    var query = {\n      dirty: false,\n      matcher: self.matcher,\n      // not fast pathed\n      sorter: ordered && self.sorter,\n      distances: self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap(),\n      resultsSnapshot: null,\n      ordered: ordered,\n      cursor: self,\n      projectionFn: self._projectionFn\n    };\n    var qid; // Non-reactive queries call added[Before] and then never call anything\n    // else.\n\n    if (self.reactive) {\n      qid = self.collection.next_qid++;\n      self.collection.queries[qid] = query;\n    }\n\n    query.results = self._getRawObjects({\n      ordered: ordered,\n      distances: query.distances\n    });\n    if (self.collection.paused) query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap(); // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n\n    var wrapCallback = function (f) {\n      if (!f) return function () {};\n      return function () /*args*/{\n        var context = this;\n        var args = arguments;\n        if (self.collection.paused) return;\n\n        self.collection._observeQueue.queueTask(function () {\n          f.apply(context, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !self.collection.paused) {\n      // XXX unify ordered and unordered interface\n      var each = ordered ? _.bind(_.each, null, query.results) : _.bind(query.results.forEach, query.results);\n      each(function (doc) {\n        var fields = EJSON.clone(doc);\n        delete fields._id;\n        if (ordered) query.addedBefore(doc._id, self._projectionFn(fields), null);\n        query.added(doc._id, self._projectionFn(fields));\n      });\n    }\n\n    var handle = new LocalCollection.ObserveHandle();\n\n    _.extend(handle, {\n      collection: self.collection,\n      stop: function () {\n        if (self.reactive) delete self.collection.queries[qid];\n      }\n    });\n\n    if (self.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(function () {\n        handle.stop();\n      });\n    } // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n\n\n    self.collection._observeQueue.drain();\n\n    return handle;\n  }\n}); // Returns a collection of matching objects, but doesn't deep copy them.\n//\n// If ordered is set, returns a sorted array, respecting sorter, skip, and limit\n// properties of the query.  if sorter is falsey, no sort -- you get the natural\n// order.\n//\n// If ordered is not set, returns an object mapping from ID to doc (sorter, skip\n// and limit should not be set).\n//\n// If ordered is set and this cursor is a $near geoquery, then this function\n// will use an _IdMap to track each distance from the $near argument point in\n// order to use it as a sort key. If an _IdMap is passed in the 'distances'\n// argument, this function will clear it and use it for this purpose (otherwise\n// it will just create its own _IdMap). The observeChanges implementation uses\n// this to remember the distances after this function returns.\n\n\nLocalCollection.Cursor.prototype._getRawObjects = function (options) {\n  var self = this;\n  options = options || {}; // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n  // compatible\n\n  var results = options.ordered ? [] : new LocalCollection._IdMap(); // fast path for single ID value\n\n  if (self._selectorId !== undefined) {\n    // If you have non-zero skip and ask for a single id, you get\n    // nothing. This is so it matches the behavior of the '{_id: foo}'\n    // path.\n    if (self.skip) return results;\n\n    var selectedDoc = self.collection._docs.get(self._selectorId);\n\n    if (selectedDoc) {\n      if (options.ordered) results.push(selectedDoc);else results.set(self._selectorId, selectedDoc);\n    }\n\n    return results;\n  } // slow path for arbitrary selector, sort, skip, limit\n  // in the observeChanges case, distances is actually part of the \"query\" (ie,\n  // live results set) object.  in other cases, distances is only used inside\n  // this function.\n\n\n  var distances;\n\n  if (self.matcher.hasGeoQuery() && options.ordered) {\n    if (options.distances) {\n      distances = options.distances;\n      distances.clear();\n    } else {\n      distances = new LocalCollection._IdMap();\n    }\n  }\n\n  self.collection._docs.forEach(function (doc, id) {\n    var matchResult = self.matcher.documentMatches(doc);\n\n    if (matchResult.result) {\n      if (options.ordered) {\n        results.push(doc);\n        if (distances && matchResult.distance !== undefined) distances.set(id, matchResult.distance);\n      } else {\n        results.set(id, doc);\n      }\n    } // Fast path for limited unsorted queries.\n    // XXX 'length' check here seems wrong for ordered\n\n\n    if (self.limit && !self.skip && !self.sorter && results.length === self.limit) return false; // break\n\n    return true; // continue\n  });\n\n  if (!options.ordered) return results;\n\n  if (self.sorter) {\n    var comparator = self.sorter.getComparator({\n      distances: distances\n    });\n    results.sort(comparator);\n  }\n\n  var idx_start = self.skip || 0;\n  var idx_end = self.limit ? self.limit + idx_start : results.length;\n  return results.slice(idx_start, idx_end);\n}; // XXX Maybe we need a version of observe that just calls a callback if\n// anything changed.\n\n\nLocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {\n  var self = this;\n\n  if (Tracker.active) {\n    var v = new Tracker.Dependency();\n    v.depend();\n\n    var notifyChange = _.bind(v.changed, v);\n\n    var options = {\n      _suppress_initial: true,\n      _allow_unordered: _allow_unordered\n    };\n\n    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'], function (fnName) {\n      if (changers[fnName]) options[fnName] = notifyChange;\n    }); // observeChanges will stop() when this computation is invalidated\n\n\n    self.observeChanges(options);\n  }\n}; // XXX enforce rule that field names can't start with '$' or contain '.'\n// (real mongodb does in fact enforce this)\n// XXX possibly enforce that 'undefined' does not appear (we assume\n// this in our handling of null and $exists)\n\n\nLocalCollection.prototype.insert = function (doc, callback) {\n  var self = this;\n  doc = EJSON.clone(doc); // Make sure field names do not contain Mongo restricted\n  // characters ('.', '$', '\\0').\n  // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n\n  if (doc) {\n    (function () {\n      var invalidCharMsg = {\n        '.': \"contain '.'\",\n        '$': \"start with '$'\",\n        '\\0': \"contain null bytes\"\n      };\n      JSON.stringify(doc, function (key, value) {\n        var match = void 0;\n\n        if (_.isString(key) && (match = key.match(/^\\$|\\.|\\0/))) {\n          throw MinimongoError(\"Key \" + key + \" must not \" + invalidCharMsg[match[0]]);\n        }\n\n        return value;\n      });\n    })();\n  }\n\n  if (!_.has(doc, '_id')) {\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n  }\n\n  var id = doc._id;\n  if (self._docs.has(id)) throw MinimongoError(\"Duplicate _id '\" + id + \"'\");\n\n  self._saveOriginal(id, undefined);\n\n  self._docs.set(id, doc);\n\n  var queriesToRecompute = []; // trigger live queries that match\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(self.queries)) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n    var matchResult = query.matcher.documentMatches(doc);\n\n    if (matchResult.result) {\n      if (query.distances && matchResult.distance !== undefined) query.distances.set(id, matchResult.distance);\n      if (query.cursor.skip || query.cursor.limit) queriesToRecompute.push(qid);else LocalCollection._insertInResults(query, doc);\n    }\n  }\n\n  _.each(queriesToRecompute, function (qid) {\n    if (self.queries[qid]) self._recomputeResults(self.queries[qid]);\n  });\n\n  self._observeQueue.drain(); // Defer because the caller likely doesn't expect the callback to be run\n  // immediately.\n\n\n  if (callback) Meteor.defer(function () {\n    callback(null, id);\n  });\n  return id;\n}; // Iterates over a subset of documents that could match selector; calls\n// f(doc, id) on each of them.  Specifically, if selector specifies\n// specific _id's, it only looks at those.  doc is *not* cloned: it is the\n// same object that is in _docs.\n\n\nLocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {\n  var self = this;\n\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n  if (specificIds) {\n    for (var i = 0; i < specificIds.length; ++i) {\n      var id = specificIds[i];\n\n      var doc = self._docs.get(id);\n\n      if (doc) {\n        var breakIfFalse = f(doc, id);\n        if (breakIfFalse === false) break;\n      }\n    }\n  } else {\n    self._docs.forEach(f);\n  }\n};\n\nLocalCollection.prototype.remove = function (selector, callback) {\n  var self = this; // Easy special case: if we're not calling observeChanges callbacks and we're\n  // not saving originals and we got asked to remove everything, then just empty\n  // everything directly.\n\n  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {\n    var result = self._docs.size();\n\n    self._docs.clear();\n\n    _.each(self.queries, function (query) {\n      if (query.ordered) {\n        query.results = [];\n      } else {\n        query.results.clear();\n      }\n    });\n\n    if (callback) {\n      Meteor.defer(function () {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  var matcher = new Minimongo.Matcher(selector);\n  var remove = [];\n\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    if (matcher.documentMatches(doc).result) remove.push(id);\n  });\n\n  var queriesToRecompute = [];\n  var queryRemove = [];\n\n  for (var i = 0; i < remove.length; i++) {\n    var removeId = remove[i];\n\n    var removeDoc = self._docs.get(removeId);\n\n    _.each(self.queries, function (query, qid) {\n      if (query.dirty) return;\n\n      if (query.matcher.documentMatches(removeDoc).result) {\n        if (query.cursor.skip || query.cursor.limit) queriesToRecompute.push(qid);else queryRemove.push({\n          qid: qid,\n          doc: removeDoc\n        });\n      }\n    });\n\n    self._saveOriginal(removeId, removeDoc);\n\n    self._docs.remove(removeId);\n  } // run live query callbacks _after_ we've removed the documents.\n\n\n  _.each(queryRemove, function (remove) {\n    var query = self.queries[remove.qid];\n\n    if (query) {\n      query.distances && query.distances.remove(remove.doc._id);\n\n      LocalCollection._removeFromResults(query, remove.doc);\n    }\n  });\n\n  _.each(queriesToRecompute, function (qid) {\n    var query = self.queries[qid];\n    if (query) self._recomputeResults(query);\n  });\n\n  self._observeQueue.drain();\n\n  result = remove.length;\n  if (callback) Meteor.defer(function () {\n    callback(null, result);\n  });\n  return result;\n}; // XXX atomicity: if multi is true, and one modification fails, do\n// we rollback the whole operation, or what?\n\n\nLocalCollection.prototype.update = function (selector, mod, options, callback) {\n  var self = this;\n\n  if (!callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (!options) options = {};\n  var matcher = new Minimongo.Matcher(selector); // Save the original results of any query that we might need to\n  // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n  // it. (We don't need to save the original results of paused queries because\n  // they already have a resultsSnapshot and we won't be diffing in\n  // _recomputeResults.)\n\n  var qidToOriginalResults = {}; // We should only clone each document once, even if it appears in multiple queries\n\n  var docMap = new LocalCollection._IdMap();\n\n  var idsMatchedBySelector = LocalCollection._idsMatchedBySelector(selector);\n\n  _.each(self.queries, function (query, qid) {\n    if ((query.cursor.skip || query.cursor.limit) && !self.paused) {\n      // Catch the case of a reactive `count()` on a cursor with skip\n      // or limit, which registers an unordered observe. This is a\n      // pretty rare case, so we just clone the entire result set with\n      // no optimizations for documents that appear in these result\n      // sets and other queries.\n      if (query.results instanceof LocalCollection._IdMap) {\n        qidToOriginalResults[qid] = query.results.clone();\n        return;\n      }\n\n      if (!(query.results instanceof Array)) {\n        throw new Error(\"Assertion failed: query.results not an array\");\n      } // Clones a document to be stored in `qidToOriginalResults`\n      // because it may be modified before the new and old result sets\n      // are diffed. But if we know exactly which document IDs we're\n      // going to modify, then we only need to clone those.\n\n\n      var memoizedCloneIfNeeded = function (doc) {\n        if (docMap.has(doc._id)) {\n          return docMap.get(doc._id);\n        } else {\n          var docToMemoize;\n\n          if (idsMatchedBySelector && !_.any(idsMatchedBySelector, function (id) {\n            return EJSON.equals(id, doc._id);\n          })) {\n            docToMemoize = doc;\n          } else {\n            docToMemoize = EJSON.clone(doc);\n          }\n\n          docMap.set(doc._id, docToMemoize);\n          return docToMemoize;\n        }\n      };\n\n      qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n    }\n  });\n\n  var recomputeQids = {};\n  var updateCount = 0;\n\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    var queryResult = matcher.documentMatches(doc);\n\n    if (queryResult.result) {\n      // XXX Should we save the original even if mod ends up being a no-op?\n      self._saveOriginal(id, doc);\n\n      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);\n\n      ++updateCount;\n      if (!options.multi) return false; // break\n    }\n\n    return true;\n  });\n\n  _.each(recomputeQids, function (dummy, qid) {\n    var query = self.queries[qid];\n    if (query) self._recomputeResults(query, qidToOriginalResults[qid]);\n  });\n\n  self._observeQueue.drain(); // If we are doing an upsert, and we didn't modify any documents yet, then\n  // it's time to do an insert. Figure out what document we are inserting, and\n  // generate an id for it.\n\n\n  var insertedId;\n\n  if (updateCount === 0 && options.upsert) {\n    var newDoc = LocalCollection._removeDollarOperators(selector);\n\n    LocalCollection._modify(newDoc, mod, {\n      isInsert: true\n    });\n\n    if (!newDoc._id && options.insertedId) newDoc._id = options.insertedId;\n    insertedId = self.insert(newDoc);\n    updateCount = 1;\n  } // Return the number of affected documents, or in the upsert case, an object\n  // containing the number of affected docs and the id of the doc that was\n  // inserted, if any.\n\n\n  var result;\n\n  if (options._returnObject) {\n    result = {\n      numberAffected: updateCount\n    };\n    if (insertedId !== undefined) result.insertedId = insertedId;\n  } else {\n    result = updateCount;\n  }\n\n  if (callback) Meteor.defer(function () {\n    callback(null, result);\n  });\n  return result;\n}; // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:\n// true }).\n\n\nLocalCollection.prototype.upsert = function (selector, mod, options, callback) {\n  var self = this;\n\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(selector, mod, _.extend({}, options, {\n    upsert: true,\n    _returnObject: true\n  }), callback);\n};\n\nLocalCollection.prototype._modifyAndNotify = function (doc, mod, recomputeQids, arrayIndices) {\n  var self = this;\n  var matched_before = {};\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(self.queries)) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n\n    if (query.ordered) {\n      matched_before[qid] = query.matcher.documentMatches(doc).result;\n    } else {\n      // Because we don't support skip or limit (yet) in unordered queries, we\n      // can just do a direct lookup.\n      matched_before[qid] = query.results.has(doc._id);\n    }\n  }\n\n  var old_doc = EJSON.clone(doc);\n\n  LocalCollection._modify(doc, mod, {\n    arrayIndices: arrayIndices\n  });\n\n  for (qid in meteorBabelHelpers.sanitizeForInObject(self.queries)) {\n    query = self.queries[qid];\n    if (query.dirty) continue;\n    var before = matched_before[qid];\n    var afterMatch = query.matcher.documentMatches(doc);\n    var after = afterMatch.result;\n    if (after && query.distances && afterMatch.distance !== undefined) query.distances.set(doc._id, afterMatch.distance);\n\n    if (query.cursor.skip || query.cursor.limit) {\n      // We need to recompute any query where the doc may have been in the\n      // cursor's window either before or after the update. (Note that if skip\n      // or limit is set, \"before\" and \"after\" being true do not necessarily\n      // mean that the document is in the cursor's output after skip/limit is\n      // applied... but if they are false, then the document definitely is NOT\n      // in the output. So it's safe to skip recompute if neither before or\n      // after are true.)\n      if (before || after) recomputeQids[qid] = true;\n    } else if (before && !after) {\n      LocalCollection._removeFromResults(query, doc);\n    } else if (!before && after) {\n      LocalCollection._insertInResults(query, doc);\n    } else if (before && after) {\n      LocalCollection._updateInResults(query, doc, old_doc);\n    }\n  }\n}; // XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n\nLocalCollection._insertInResults = function (query, doc) {\n  var fields = EJSON.clone(doc);\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      var i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n        distances: query.distances\n      }), query.results, doc);\n\n      var next = query.results[i + 1];\n      if (next) next = next._id;else next = null;\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._removeFromResults = function (query, doc) {\n  if (query.ordered) {\n    var i = LocalCollection._findInOrderedResults(query, doc);\n\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    var id = doc._id; // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\nLocalCollection._updateInResults = function (query, doc, old_doc) {\n  if (!EJSON.equals(doc._id, old_doc._id)) throw new Error(\"Can't change a doc's _id while updating\");\n  var projectionFn = query.projectionFn;\n  var changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n\n  if (!query.ordered) {\n    if (!_.isEmpty(changedFields)) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  var orig_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (!_.isEmpty(changedFields)) query.changed(doc._id, changedFields);\n  if (!query.sorter) return; // just take it out and put it back in again, and see if the index\n  // changes\n\n  query.results.splice(orig_idx, 1);\n\n  var new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n    distances: query.distances\n  }), query.results, doc);\n\n  if (orig_idx !== new_idx) {\n    var next = query.results[new_idx + 1];\n    if (next) next = next._id;else next = null;\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n}; // Recomputes the results of a query and runs observe callbacks for the\n// difference between the previous results and the current results (unless\n// paused). Used for skip/limit queries.\n//\n// When this is used by insert or remove, it can just use query.results for the\n// old results (and there's no need to pass in oldResults), because these\n// operations don't mutate the documents in the collection. Update needs to pass\n// in an oldResults which was deep-copied before the modifier was applied.\n//\n// oldResults is guaranteed to be ignored if the query is not paused.\n\n\nLocalCollection.prototype._recomputeResults = function (query, oldResults) {\n  var self = this;\n\n  if (self.paused) {\n    // There's no reason to recompute the results now as we're still paused.\n    // By flagging the query as \"dirty\", the recompute will be performed\n    // when resumeObservers is called.\n    query.dirty = true;\n    return;\n  }\n\n  if (!self.paused && !oldResults) oldResults = query.results;\n  if (query.distances) query.distances.clear();\n  query.results = query.cursor._getRawObjects({\n    ordered: query.ordered,\n    distances: query.distances\n  });\n\n  if (!self.paused) {\n    LocalCollection._diffQueryChanges(query.ordered, oldResults, query.results, query, {\n      projectionFn: query.projectionFn\n    });\n  }\n};\n\nLocalCollection._findInOrderedResults = function (query, doc) {\n  if (!query.ordered) throw new Error(\"Can't call _findInOrderedResults on unordered query\");\n\n  for (var i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) return i;\n  }\n\n  throw Error(\"object missing from query\");\n}; // This binary search puts a value between any equal values, and the first\n// lesser value.\n\n\nLocalCollection._binarySearch = function (cmp, array, value) {\n  var first = 0,\n      rangeLength = array.length;\n\n  while (rangeLength > 0) {\n    var halfRange = Math.floor(rangeLength / 2);\n\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      rangeLength -= halfRange + 1;\n    } else {\n      rangeLength = halfRange;\n    }\n  }\n\n  return first;\n};\n\nLocalCollection._insertInSortedList = function (cmp, array, value) {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  var idx = LocalCollection._binarySearch(cmp, array, value);\n\n  array.splice(idx, 0, value);\n  return idx;\n}; // To track what documents are affected by a piece of code, call saveOriginals()\n// before it and retrieveOriginals() after it. retrieveOriginals returns an\n// object whose keys are the ids of the documents that were affected since the\n// call to saveOriginals(), and the values are equal to the document's contents\n// at the time of saveOriginals. (In the case of an inserted document, undefined\n// is the value.) You must alternate between calls to saveOriginals() and\n// retrieveOriginals().\n\n\nLocalCollection.prototype.saveOriginals = function () {\n  var self = this;\n  if (self._savedOriginals) throw new Error(\"Called saveOriginals twice without retrieveOriginals\");\n  self._savedOriginals = new LocalCollection._IdMap();\n};\n\nLocalCollection.prototype.retrieveOriginals = function () {\n  var self = this;\n  if (!self._savedOriginals) throw new Error(\"Called retrieveOriginals without saveOriginals\");\n  var originals = self._savedOriginals;\n  self._savedOriginals = null;\n  return originals;\n};\n\nLocalCollection.prototype._saveOriginal = function (id, doc) {\n  var self = this; // Are we even trying to save originals?\n\n  if (!self._savedOriginals) return; // Have we previously mutated the original (and so 'doc' is not actually\n  // original)?  (Note the 'has' check rather than truth: we store undefined\n  // here for inserted docs!)\n\n  if (self._savedOriginals.has(id)) return;\n\n  self._savedOriginals.set(id, EJSON.clone(doc));\n}; // Pause the observers. No callbacks from observers will fire until\n// 'resumeObservers' is called.\n\n\nLocalCollection.prototype.pauseObservers = function () {\n  // No-op if already paused.\n  if (this.paused) return; // Set the 'paused' flag such that new observer messages don't fire.\n\n  this.paused = true; // Take a snapshot of the query results for each query.\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(this.queries)) {\n    var query = this.queries[qid];\n    query.resultsSnapshot = EJSON.clone(query.results);\n  }\n}; // Resume the observers. Observers immediately receive change\n// notifications to bring them to the current state of the\n// database. Note that this is not just replaying all the changes that\n// happened during the pause, it is a smarter 'coalesced' diff.\n\n\nLocalCollection.prototype.resumeObservers = function () {\n  var self = this; // No-op if not paused.\n\n  if (!this.paused) return; // Unset the 'paused' flag. Make sure to do this first, otherwise\n  // observer methods won't actually fire when we trigger them.\n\n  this.paused = false;\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(this.queries)) {\n    var query = self.queries[qid];\n\n    if (query.dirty) {\n      query.dirty = false; // re-compute results will perform `LocalCollection._diffQueryChanges` automatically.\n\n      self._recomputeResults(query, query.resultsSnapshot);\n    } else {\n      // Diff the current results against the snapshot and send to observers.\n      // pass the query object for its observer callbacks.\n      LocalCollection._diffQueryChanges(query.ordered, query.resultsSnapshot, query.results, query, {\n        projectionFn: query.projectionFn\n      });\n    }\n\n    query.resultsSnapshot = null;\n  }\n\n  self._observeQueue.drain();\n};","ast":null,"map":{"version":3,"sources":["/packages/minimongo/minimongo.js"],"names":["LocalCollection","name","self","_docs","_IdMap","_observeQueue","Meteor","_SynchronousQueue","next_qid","queries","_savedOriginals","paused","Minimongo","MinimongoTest","MinimongoError","message","e","Error","prototype","find","selector","options","arguments","length","Cursor","collection","sorter","matcher","Matcher","_selectorIsId","_selectorId","_selectorIsIdPerhapsAsObject","_id","undefined","hasGeoQuery","sort","Sorter","skip","limit","fields","_projectionFn","_compileProjection","_transform","wrapTransform","transform","Tracker","reactive","rewind","findOne","fetch","forEach","callback","thisArg","objects","_getRawObjects","ordered","_depend","addedBefore","removed","changed","movedBefore","_","each","elt","i","call","getTransform","map","res","doc","index","push","count","added","_publishCursor","sub","Package","mongo","Mongo","Collection","_getCollectionName","_observeChangesCallbacksAreOrdered","callbacks","_observeCallbacksAreOrdered","addedAt","changedAt","removedAt","movedTo","ObserveHandle","extend","observe","_observeFromObserveChanges","observeChanges","_allow_unordered","query","dirty","distances","resultsSnapshot","cursor","projectionFn","qid","results","wrapCallback","f","context","args","queueTask","apply","_suppress_initial","bind","EJSON","clone","handle","stop","active","onInvalidate","drain","selectedDoc","get","set","clear","id","matchResult","documentMatches","result","distance","comparator","getComparator","idx_start","idx_end","slice","changers","v","Dependency","depend","notifyChange","fnName","insert","invalidCharMsg","JSON","stringify","key","value","match","isString","has","_useOID","MongoID","ObjectID","Random","_saveOriginal","queriesToRecompute","_insertInResults","_recomputeResults","defer","_eachPossiblyMatchingDoc","specificIds","_idsMatchedBySelector","breakIfFalse","remove","equals","size","queryRemove","removeId","removeDoc","_removeFromResults","update","mod","Function","qidToOriginalResults","docMap","idsMatchedBySelector","Array","memoizedCloneIfNeeded","docToMemoize","any","recomputeQids","updateCount","queryResult","_modifyAndNotify","arrayIndices","multi","dummy","insertedId","upsert","newDoc","_removeDollarOperators","_modify","isInsert","_returnObject","numberAffected","matched_before","old_doc","before","afterMatch","after","_updateInResults","_insertInSortedList","next","_findInOrderedResults","splice","changedFields","DiffSequence","makeChangedFields","isEmpty","orig_idx","new_idx","oldResults","_diffQueryChanges","_binarySearch","cmp","array","first","rangeLength","halfRange","Math","floor","idx","saveOriginals","retrieveOriginals","originals","pauseObservers","resumeObservers"],"mappings":"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","file":"/packages/minimongo/minimongo.js.map","sourcesContent":["// XXX type checking on selectors (graceful error if malformed)\n\n// LocalCollection: a set of documents that supports queries and modifiers.\n\n// Cursor: a specification for a particular subset of documents, w/\n// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),\n\n// ObserveHandle: the return value of a live query.\n\nLocalCollection = function (name) {\n  var self = this;\n  self.name = name;\n  // _id -> document (also containing id)\n  self._docs = new LocalCollection._IdMap;\n\n  self._observeQueue = new Meteor._SynchronousQueue();\n\n  self.next_qid = 1; // live query id generator\n\n  // qid -> live query object. keys:\n  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n  //  results: array (ordered) or object (unordered) of current results\n  //    (aliased with self._docs!)\n  //  resultsSnapshot: snapshot of results. null if not paused.\n  //  cursor: Cursor object for the query.\n  //  selector, sorter, (callbacks): functions\n  self.queries = {};\n\n  // null if not saving originals; an IdMap from id to original document value if\n  // saving originals. See comments before saveOriginals().\n  self._savedOriginals = null;\n\n  // True when observers are paused and we should not send callbacks.\n  self.paused = false;\n};\n\nMinimongo = {};\n\n// Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\nMinimongoTest = {};\n\nMinimongoError = function (message) {\n  var e = new Error(message);\n  e.name = \"MinimongoError\";\n  return e;\n};\n\n\n// options may include sort, skip, limit, reactive\n// sort may be any of these forms:\n//     {a: 1, b: -1}\n//     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n//     [\"a\", [\"b\", \"desc\"]]\n//   (in the first form you're beholden to key enumeration order in\n//   your javascript VM)\n//\n// reactive: if given, and false, don't register with Tracker (default\n// is true)\n//\n// XXX possibly should support retrieving a subset of fields? and\n// have it be a hint (ignored on the client, when not copying the\n// doc?)\n//\n// XXX sort does not yet support subkeys ('a.b') .. fix that!\n// XXX add one more sort form: \"key\"\n// XXX tests\nLocalCollection.prototype.find = function (selector, options) {\n  // default syntax for everything is to omit the selector argument.\n  // but if selector is explicitly passed in as false or undefined, we\n  // want a selector that matches nothing.\n  if (arguments.length === 0)\n    selector = {};\n\n  return new LocalCollection.Cursor(this, selector, options);\n};\n\n// don't call this ctor directly.  use LocalCollection.find().\n\nLocalCollection.Cursor = function (collection, selector, options) {\n  var self = this;\n  if (!options) options = {};\n\n  self.collection = collection;\n  self.sorter = null;\n  self.matcher = new Minimongo.Matcher(selector);\n\n  if (LocalCollection._selectorIsId(selector)) {\n    // stash for fast path\n    self._selectorId = selector;\n  } else if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    // also do the fast path for { _id: idString }\n    self._selectorId = selector._id;\n  } else {\n    self._selectorId = undefined;\n    if (self.matcher.hasGeoQuery() || options.sort) {\n      self.sorter = new Minimongo.Sorter(options.sort || [],\n                                         { matcher: self.matcher });\n    }\n  }\n\n  self.skip = options.skip;\n  self.limit = options.limit;\n  self.fields = options.fields;\n\n  self._projectionFn = LocalCollection._compileProjection(self.fields || {});\n\n  self._transform = LocalCollection.wrapTransform(options.transform);\n\n  // by default, queries register w/ Tracker when it is available.\n  if (typeof Tracker !== \"undefined\")\n    self.reactive = (options.reactive === undefined) ? true : options.reactive;\n};\n\n// Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\nLocalCollection.Cursor.prototype.rewind = function () {\n};\n\nLocalCollection.prototype.findOne = function (selector, options) {\n  if (arguments.length === 0)\n    selector = {};\n\n  // NOTE: by setting limit 1 here, we end up using very inefficient\n  // code that recomputes the whole query on each update. The upside is\n  // that when you reactively depend on a findOne you only get\n  // invalidated when the found object changes, not any object in the\n  // collection. Most findOne will be by id, which has a fast path, so\n  // this might not be a big deal. In most cases, invalidation causes\n  // the called to re-query anyway, so this should be a net performance\n  // improvement.\n  options = options || {};\n  options.limit = 1;\n\n  return this.find(selector, options).fetch()[0];\n};\n\n/**\n * @callback IterationCallback\n * @param {Object} doc\n * @param {Number} index\n */\n/**\n * @summary Call `callback` once for each matching document, sequentially and synchronously.\n * @locus Anywhere\n * @method  forEach\n * @instance\n * @memberOf Mongo.Cursor\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n */\nLocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {\n  var self = this;\n\n  var objects = self._getRawObjects({ordered: true});\n\n  if (self.reactive) {\n    self._depend({\n      addedBefore: true,\n      removed: true,\n      changed: true,\n      movedBefore: true});\n  }\n\n  _.each(objects, function (elt, i) {\n    // This doubles as a clone operation.\n    elt = self._projectionFn(elt);\n\n    if (self._transform)\n      elt = self._transform(elt);\n    callback.call(thisArg, elt, i, self);\n  });\n};\n\nLocalCollection.Cursor.prototype.getTransform = function () {\n  return this._transform;\n};\n\n/**\n * @summary Map callback over all matching documents.  Returns an Array.\n * @locus Anywhere\n * @method map\n * @instance\n * @memberOf Mongo.Cursor\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n */\nLocalCollection.Cursor.prototype.map = function (callback, thisArg) {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc, index) {\n    res.push(callback.call(thisArg, doc, index, self));\n  });\n  return res;\n};\n\n/**\n * @summary Return all matching documents as an Array.\n * @memberOf Mongo.Cursor\n * @method  fetch\n * @instance\n * @locus Anywhere\n * @returns {Object[]}\n */\nLocalCollection.Cursor.prototype.fetch = function () {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc) {\n    res.push(doc);\n  });\n  return res;\n};\n\n/**\n * @summary Returns the number of documents that match a query.\n * @memberOf Mongo.Cursor\n * @method  count\n * @instance\n * @locus Anywhere\n * @returns {Number}\n */\nLocalCollection.Cursor.prototype.count = function () {\n  var self = this;\n\n  if (self.reactive)\n    self._depend({added: true, removed: true},\n                 true /* allow the observe to be unordered */);\n\n  return self._getRawObjects({ordered: true}).length;\n};\n\nLocalCollection.Cursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  if (! self.collection.name)\n    throw new Error(\"Can't publish a cursor from a collection without a name.\");\n  var collection = self.collection.name;\n\n  // XXX minimongo should not depend on mongo-livedata!\n  if (! Package.mongo) {\n    throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");\n  }\n\n  return Package.mongo.Mongo.Collection._publishCursor(self, sub, collection);\n};\n\nLocalCollection.Cursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self.collection.name;\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedBefore)\n    throw new Error(\"Please specify only one of added() and addedBefore()\");\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.addedAt && callbacks.added)\n    throw new Error(\"Please specify only one of added() and addedAt()\");\n  if (callbacks.changedAt && callbacks.changed)\n    throw new Error(\"Please specify only one of changed() and changedAt()\");\n  if (callbacks.removed && callbacks.removedAt)\n    throw new Error(\"Please specify only one of removed() and removedAt()\");\n\n  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt\n            || callbacks.removedAt);\n};\n\n// the handle that comes back from observe.\nLocalCollection.ObserveHandle = function () {};\n\n// options to contain:\n//  * callbacks for observe():\n//    - addedAt (document, atIndex)\n//    - added (document)\n//    - changedAt (newDocument, oldDocument, atIndex)\n//    - changed (newDocument, oldDocument)\n//    - removedAt (document, atIndex)\n//    - removed (document)\n//    - movedTo (document, oldIndex, newIndex)\n//\n// attributes available on returned query handle:\n//  * stop(): end updates\n//  * collection: the collection this query is querying\n//\n// iff x is a returned query handle, (x instanceof\n// LocalCollection.ObserveHandle) is true\n//\n// initial results delivered through added callback\n// XXX maybe callbacks should take a list of objects, to expose transactions?\n// XXX maybe support field limiting (to limit what you're notified on)\n\n_.extend(LocalCollection.Cursor.prototype, {\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */\n  observe: function (options) {\n    var self = this;\n    return LocalCollection._observeFromObserveChanges(self, options);\n  },\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.  Only the differences between the old and new documents are passed to the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */\n  observeChanges: function (options) {\n    var self = this;\n\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (self.skip || self.limit))\n      throw new Error(\"must use ordered observe (ie, 'addedBefore' instead of 'added') with skip or limit\");\n\n    if (self.fields && (self.fields._id === 0 || self.fields._id === false))\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n\n    var query = {\n      dirty: false,\n      matcher: self.matcher, // not fast pathed\n      sorter: ordered && self.sorter,\n      distances: (\n        self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap),\n      resultsSnapshot: null,\n      ordered: ordered,\n      cursor: self,\n      projectionFn: self._projectionFn\n    };\n    var qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (self.reactive) {\n      qid = self.collection.next_qid++;\n      self.collection.queries[qid] = query;\n    }\n    query.results = self._getRawObjects({\n      ordered: ordered, distances: query.distances});\n    if (self.collection.paused)\n      query.resultsSnapshot = (ordered ? [] : new LocalCollection._IdMap);\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    var wrapCallback = function (f) {\n      if (!f)\n        return function () {};\n      return function (/*args*/) {\n        var context = this;\n        var args = arguments;\n\n        if (self.collection.paused)\n          return;\n\n        self.collection._observeQueue.queueTask(function () {\n          f.apply(context, args);\n        });\n      };\n    };\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !self.collection.paused) {\n      // XXX unify ordered and unordered interface\n      var each = ordered\n            ? _.bind(_.each, null, query.results)\n            : _.bind(query.results.forEach, query.results);\n      each(function (doc) {\n        var fields = EJSON.clone(doc);\n\n        delete fields._id;\n        if (ordered)\n          query.addedBefore(doc._id, self._projectionFn(fields), null);\n        query.added(doc._id, self._projectionFn(fields));\n      });\n    }\n\n    var handle = new LocalCollection.ObserveHandle;\n    _.extend(handle, {\n      collection: self.collection,\n      stop: function () {\n        if (self.reactive)\n          delete self.collection.queries[qid];\n      }\n    });\n\n    if (self.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(function () {\n        handle.stop();\n      });\n    }\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    self.collection._observeQueue.drain();\n\n    return handle;\n  }\n});\n\n// Returns a collection of matching objects, but doesn't deep copy them.\n//\n// If ordered is set, returns a sorted array, respecting sorter, skip, and limit\n// properties of the query.  if sorter is falsey, no sort -- you get the natural\n// order.\n//\n// If ordered is not set, returns an object mapping from ID to doc (sorter, skip\n// and limit should not be set).\n//\n// If ordered is set and this cursor is a $near geoquery, then this function\n// will use an _IdMap to track each distance from the $near argument point in\n// order to use it as a sort key. If an _IdMap is passed in the 'distances'\n// argument, this function will clear it and use it for this purpose (otherwise\n// it will just create its own _IdMap). The observeChanges implementation uses\n// this to remember the distances after this function returns.\nLocalCollection.Cursor.prototype._getRawObjects = function (options) {\n  var self = this;\n  options = options || {};\n\n  // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n  // compatible\n  var results = options.ordered ? [] : new LocalCollection._IdMap;\n\n  // fast path for single ID value\n  if (self._selectorId !== undefined) {\n    // If you have non-zero skip and ask for a single id, you get\n    // nothing. This is so it matches the behavior of the '{_id: foo}'\n    // path.\n    if (self.skip)\n      return results;\n\n    var selectedDoc = self.collection._docs.get(self._selectorId);\n    if (selectedDoc) {\n      if (options.ordered)\n        results.push(selectedDoc);\n      else\n        results.set(self._selectorId, selectedDoc);\n    }\n    return results;\n  }\n\n  // slow path for arbitrary selector, sort, skip, limit\n\n  // in the observeChanges case, distances is actually part of the \"query\" (ie,\n  // live results set) object.  in other cases, distances is only used inside\n  // this function.\n  var distances;\n  if (self.matcher.hasGeoQuery() && options.ordered) {\n    if (options.distances) {\n      distances = options.distances;\n      distances.clear();\n    } else {\n      distances = new LocalCollection._IdMap();\n    }\n  }\n\n  self.collection._docs.forEach(function (doc, id) {\n    var matchResult = self.matcher.documentMatches(doc);\n    if (matchResult.result) {\n      if (options.ordered) {\n        results.push(doc);\n        if (distances && matchResult.distance !== undefined)\n          distances.set(id, matchResult.distance);\n      } else {\n        results.set(id, doc);\n      }\n    }\n    // Fast path for limited unsorted queries.\n    // XXX 'length' check here seems wrong for ordered\n    if (self.limit && !self.skip && !self.sorter &&\n        results.length === self.limit)\n      return false;  // break\n    return true;  // continue\n  });\n\n  if (!options.ordered)\n    return results;\n\n  if (self.sorter) {\n    var comparator = self.sorter.getComparator({distances: distances});\n    results.sort(comparator);\n  }\n\n  var idx_start = self.skip || 0;\n  var idx_end = self.limit ? (self.limit + idx_start) : results.length;\n  return results.slice(idx_start, idx_end);\n};\n\n// XXX Maybe we need a version of observe that just calls a callback if\n// anything changed.\nLocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {\n  var self = this;\n\n  if (Tracker.active) {\n    var v = new Tracker.Dependency;\n    v.depend();\n    var notifyChange = _.bind(v.changed, v);\n\n    var options = {\n      _suppress_initial: true,\n      _allow_unordered: _allow_unordered\n    };\n    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'],\n           function (fnName) {\n             if (changers[fnName])\n               options[fnName] = notifyChange;\n           });\n\n    // observeChanges will stop() when this computation is invalidated\n    self.observeChanges(options);\n  }\n};\n\n// XXX enforce rule that field names can't start with '$' or contain '.'\n// (real mongodb does in fact enforce this)\n// XXX possibly enforce that 'undefined' does not appear (we assume\n// this in our handling of null and $exists)\nLocalCollection.prototype.insert = function (doc, callback) {\n  var self = this;\n  doc = EJSON.clone(doc);\n\n  // Make sure field names do not contain Mongo restricted\n  // characters ('.', '$', '\\0').\n  // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n  if (doc) {\n    const invalidCharMsg = {\n      '.': \"contain '.'\",\n      '$': \"start with '$'\",\n      '\\0': \"contain null bytes\",\n    };\n    JSON.stringify(doc, (key, value) => {\n      let match;\n      if (_.isString(key) && (match = key.match(/^\\$|\\.|\\0/))) {\n        throw MinimongoError(`Key ${key} must not ${invalidCharMsg[match[0]]}`);\n      }\n      return value;\n    });\n  }\n\n  if (!_.has(doc, '_id')) {\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    doc._id = LocalCollection._useOID ? new MongoID.ObjectID()\n                                      : Random.id();\n  }\n  var id = doc._id;\n\n  if (self._docs.has(id))\n    throw MinimongoError(\"Duplicate _id '\" + id + \"'\");\n\n  self._saveOriginal(id, undefined);\n  self._docs.set(id, doc);\n\n  var queriesToRecompute = [];\n  // trigger live queries that match\n  for (var qid in self.queries) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n    var matchResult = query.matcher.documentMatches(doc);\n    if (matchResult.result) {\n      if (query.distances && matchResult.distance !== undefined)\n        query.distances.set(id, matchResult.distance);\n      if (query.cursor.skip || query.cursor.limit)\n        queriesToRecompute.push(qid);\n      else\n        LocalCollection._insertInResults(query, doc);\n    }\n  }\n\n  _.each(queriesToRecompute, function (qid) {\n    if (self.queries[qid])\n      self._recomputeResults(self.queries[qid]);\n  });\n  self._observeQueue.drain();\n\n  // Defer because the caller likely doesn't expect the callback to be run\n  // immediately.\n  if (callback)\n    Meteor.defer(function () {\n      callback(null, id);\n    });\n  return id;\n};\n\n// Iterates over a subset of documents that could match selector; calls\n// f(doc, id) on each of them.  Specifically, if selector specifies\n// specific _id's, it only looks at those.  doc is *not* cloned: it is the\n// same object that is in _docs.\nLocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {\n  var self = this;\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    for (var i = 0; i < specificIds.length; ++i) {\n      var id = specificIds[i];\n      var doc = self._docs.get(id);\n      if (doc) {\n        var breakIfFalse = f(doc, id);\n        if (breakIfFalse === false)\n          break;\n      }\n    }\n  } else {\n    self._docs.forEach(f);\n  }\n};\n\nLocalCollection.prototype.remove = function (selector, callback) {\n  var self = this;\n\n  // Easy special case: if we're not calling observeChanges callbacks and we're\n  // not saving originals and we got asked to remove everything, then just empty\n  // everything directly.\n  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {\n    var result = self._docs.size();\n    self._docs.clear();\n    _.each(self.queries, function (query) {\n      if (query.ordered) {\n        query.results = [];\n      } else {\n        query.results.clear();\n      }\n    });\n    if (callback) {\n      Meteor.defer(function () {\n        callback(null, result);\n      });\n    }\n    return result;\n  }\n\n  var matcher = new Minimongo.Matcher(selector);\n  var remove = [];\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    if (matcher.documentMatches(doc).result)\n      remove.push(id);\n  });\n\n  var queriesToRecompute = [];\n  var queryRemove = [];\n  for (var i = 0; i < remove.length; i++) {\n    var removeId = remove[i];\n    var removeDoc = self._docs.get(removeId);\n    _.each(self.queries, function (query, qid) {\n      if (query.dirty) return;\n\n      if (query.matcher.documentMatches(removeDoc).result) {\n        if (query.cursor.skip || query.cursor.limit)\n          queriesToRecompute.push(qid);\n        else\n          queryRemove.push({qid: qid, doc: removeDoc});\n      }\n    });\n    self._saveOriginal(removeId, removeDoc);\n    self._docs.remove(removeId);\n  }\n\n  // run live query callbacks _after_ we've removed the documents.\n  _.each(queryRemove, function (remove) {\n    var query = self.queries[remove.qid];\n    if (query) {\n      query.distances && query.distances.remove(remove.doc._id);\n      LocalCollection._removeFromResults(query, remove.doc);\n    }\n  });\n  _.each(queriesToRecompute, function (qid) {\n    var query = self.queries[qid];\n    if (query)\n      self._recomputeResults(query);\n  });\n  self._observeQueue.drain();\n  result = remove.length;\n  if (callback)\n    Meteor.defer(function () {\n      callback(null, result);\n    });\n  return result;\n};\n\n// XXX atomicity: if multi is true, and one modification fails, do\n// we rollback the whole operation, or what?\nLocalCollection.prototype.update = function (selector, mod, options, callback) {\n  var self = this;\n  if (! callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n  if (!options) options = {};\n\n  var matcher = new Minimongo.Matcher(selector);\n\n  // Save the original results of any query that we might need to\n  // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n  // it. (We don't need to save the original results of paused queries because\n  // they already have a resultsSnapshot and we won't be diffing in\n  // _recomputeResults.)\n  var qidToOriginalResults = {};\n  // We should only clone each document once, even if it appears in multiple queries\n  var docMap = new LocalCollection._IdMap;\n  var idsMatchedBySelector = LocalCollection._idsMatchedBySelector(selector);\n\n  _.each(self.queries, function (query, qid) {\n    if ((query.cursor.skip || query.cursor.limit) && ! self.paused) {\n      // Catch the case of a reactive `count()` on a cursor with skip\n      // or limit, which registers an unordered observe. This is a\n      // pretty rare case, so we just clone the entire result set with\n      // no optimizations for documents that appear in these result\n      // sets and other queries.\n      if (query.results instanceof LocalCollection._IdMap) {\n        qidToOriginalResults[qid] = query.results.clone();\n        return;\n      }\n\n      if (!(query.results instanceof Array)) {\n        throw new Error(\"Assertion failed: query.results not an array\");\n      }\n\n      // Clones a document to be stored in `qidToOriginalResults`\n      // because it may be modified before the new and old result sets\n      // are diffed. But if we know exactly which document IDs we're\n      // going to modify, then we only need to clone those.\n      var memoizedCloneIfNeeded = function(doc) {\n        if (docMap.has(doc._id)) {\n          return docMap.get(doc._id);\n        } else {\n          var docToMemoize;\n\n          if (idsMatchedBySelector && !_.any(idsMatchedBySelector, function(id) {\n            return EJSON.equals(id, doc._id);\n          })) {\n            docToMemoize = doc;\n          } else {\n            docToMemoize = EJSON.clone(doc);\n          }\n\n          docMap.set(doc._id, docToMemoize);\n          return docToMemoize;\n        }\n      };\n\n      qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n    }\n  });\n  var recomputeQids = {};\n\n  var updateCount = 0;\n\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    var queryResult = matcher.documentMatches(doc);\n    if (queryResult.result) {\n      // XXX Should we save the original even if mod ends up being a no-op?\n      self._saveOriginal(id, doc);\n      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);\n      ++updateCount;\n      if (!options.multi)\n        return false;  // break\n    }\n    return true;\n  });\n\n  _.each(recomputeQids, function (dummy, qid) {\n    var query = self.queries[qid];\n    if (query)\n      self._recomputeResults(query, qidToOriginalResults[qid]);\n  });\n  self._observeQueue.drain();\n\n  // If we are doing an upsert, and we didn't modify any documents yet, then\n  // it's time to do an insert. Figure out what document we are inserting, and\n  // generate an id for it.\n  var insertedId;\n  if (updateCount === 0 && options.upsert) {\n    var newDoc = LocalCollection._removeDollarOperators(selector);\n    LocalCollection._modify(newDoc, mod, {isInsert: true});\n    if (! newDoc._id && options.insertedId)\n      newDoc._id = options.insertedId;\n    insertedId = self.insert(newDoc);\n    updateCount = 1;\n  }\n\n  // Return the number of affected documents, or in the upsert case, an object\n  // containing the number of affected docs and the id of the doc that was\n  // inserted, if any.\n  var result;\n  if (options._returnObject) {\n    result = {\n      numberAffected: updateCount\n    };\n    if (insertedId !== undefined)\n      result.insertedId = insertedId;\n  } else {\n    result = updateCount;\n  }\n\n  if (callback)\n    Meteor.defer(function () {\n      callback(null, result);\n    });\n  return result;\n};\n\n// A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:\n// true }).\nLocalCollection.prototype.upsert = function (selector, mod, options, callback) {\n  var self = this;\n  if (! callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  return self.update(selector, mod, _.extend({}, options, {\n    upsert: true,\n    _returnObject: true\n  }), callback);\n};\n\nLocalCollection.prototype._modifyAndNotify = function (\n    doc, mod, recomputeQids, arrayIndices) {\n  var self = this;\n\n  var matched_before = {};\n  for (var qid in self.queries) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n\n    if (query.ordered) {\n      matched_before[qid] = query.matcher.documentMatches(doc).result;\n    } else {\n      // Because we don't support skip or limit (yet) in unordered queries, we\n      // can just do a direct lookup.\n      matched_before[qid] = query.results.has(doc._id);\n    }\n  }\n\n  var old_doc = EJSON.clone(doc);\n\n  LocalCollection._modify(doc, mod, {arrayIndices: arrayIndices});\n\n  for (qid in self.queries) {\n    query = self.queries[qid];\n    if (query.dirty) continue;\n\n    var before = matched_before[qid];\n    var afterMatch = query.matcher.documentMatches(doc);\n    var after = afterMatch.result;\n    if (after && query.distances && afterMatch.distance !== undefined)\n      query.distances.set(doc._id, afterMatch.distance);\n\n    if (query.cursor.skip || query.cursor.limit) {\n      // We need to recompute any query where the doc may have been in the\n      // cursor's window either before or after the update. (Note that if skip\n      // or limit is set, \"before\" and \"after\" being true do not necessarily\n      // mean that the document is in the cursor's output after skip/limit is\n      // applied... but if they are false, then the document definitely is NOT\n      // in the output. So it's safe to skip recompute if neither before or\n      // after are true.)\n      if (before || after)\n        recomputeQids[qid] = true;\n    } else if (before && !after) {\n      LocalCollection._removeFromResults(query, doc);\n    } else if (!before && after) {\n      LocalCollection._insertInResults(query, doc);\n    } else if (before && after) {\n      LocalCollection._updateInResults(query, doc, old_doc);\n    }\n  }\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\nLocalCollection._insertInResults = function (query, doc) {\n  var fields = EJSON.clone(doc);\n  delete fields._id;\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      var i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results, doc);\n      var next = query.results[i+1];\n      if (next)\n        next = next._id;\n      else\n        next = null;\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._removeFromResults = function (query, doc) {\n  if (query.ordered) {\n    var i = LocalCollection._findInOrderedResults(query, doc);\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    var id = doc._id;  // in case callback mutates doc\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\nLocalCollection._updateInResults = function (query, doc, old_doc) {\n  if (!EJSON.equals(doc._id, old_doc._id))\n    throw new Error(\"Can't change a doc's _id while updating\");\n  var projectionFn = query.projectionFn;\n  var changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc), projectionFn(old_doc));\n\n  if (!query.ordered) {\n    if (!_.isEmpty(changedFields)) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n    return;\n  }\n\n  var orig_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (!_.isEmpty(changedFields))\n    query.changed(doc._id, changedFields);\n  if (!query.sorter)\n    return;\n\n  // just take it out and put it back in again, and see if the index\n  // changes\n  query.results.splice(orig_idx, 1);\n  var new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results, doc);\n  if (orig_idx !== new_idx) {\n    var next = query.results[new_idx+1];\n    if (next)\n      next = next._id;\n    else\n      next = null;\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\n\n// Recomputes the results of a query and runs observe callbacks for the\n// difference between the previous results and the current results (unless\n// paused). Used for skip/limit queries.\n//\n// When this is used by insert or remove, it can just use query.results for the\n// old results (and there's no need to pass in oldResults), because these\n// operations don't mutate the documents in the collection. Update needs to pass\n// in an oldResults which was deep-copied before the modifier was applied.\n//\n// oldResults is guaranteed to be ignored if the query is not paused.\nLocalCollection.prototype._recomputeResults = function (query, oldResults) {\n  var self = this;\n  if (self.paused) {\n    // There's no reason to recompute the results now as we're still paused.\n    // By flagging the query as \"dirty\", the recompute will be performed\n    // when resumeObservers is called.\n    query.dirty = true;\n    return;\n  }\n\n  if (! self.paused && ! oldResults)\n    oldResults = query.results;\n  if (query.distances)\n    query.distances.clear();\n  query.results = query.cursor._getRawObjects({\n    ordered: query.ordered, distances: query.distances});\n\n  if (! self.paused) {\n    LocalCollection._diffQueryChanges(\n      query.ordered, oldResults, query.results, query,\n      { projectionFn: query.projectionFn });\n  }\n};\n\n\nLocalCollection._findInOrderedResults = function (query, doc) {\n  if (!query.ordered)\n    throw new Error(\"Can't call _findInOrderedResults on unordered query\");\n  for (var i = 0; i < query.results.length; i++)\n    if (query.results[i] === doc)\n      return i;\n  throw Error(\"object missing from query\");\n};\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = function (cmp, array, value) {\n  var first = 0, rangeLength = array.length;\n\n  while (rangeLength > 0) {\n    var halfRange = Math.floor(rangeLength/2);\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      rangeLength -= halfRange + 1;\n    } else {\n      rangeLength = halfRange;\n    }\n  }\n  return first;\n};\n\nLocalCollection._insertInSortedList = function (cmp, array, value) {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  var idx = LocalCollection._binarySearch(cmp, array, value);\n  array.splice(idx, 0, value);\n  return idx;\n};\n\n// To track what documents are affected by a piece of code, call saveOriginals()\n// before it and retrieveOriginals() after it. retrieveOriginals returns an\n// object whose keys are the ids of the documents that were affected since the\n// call to saveOriginals(), and the values are equal to the document's contents\n// at the time of saveOriginals. (In the case of an inserted document, undefined\n// is the value.) You must alternate between calls to saveOriginals() and\n// retrieveOriginals().\nLocalCollection.prototype.saveOriginals = function () {\n  var self = this;\n  if (self._savedOriginals)\n    throw new Error(\"Called saveOriginals twice without retrieveOriginals\");\n  self._savedOriginals = new LocalCollection._IdMap;\n};\nLocalCollection.prototype.retrieveOriginals = function () {\n  var self = this;\n  if (!self._savedOriginals)\n    throw new Error(\"Called retrieveOriginals without saveOriginals\");\n\n  var originals = self._savedOriginals;\n  self._savedOriginals = null;\n  return originals;\n};\n\nLocalCollection.prototype._saveOriginal = function (id, doc) {\n  var self = this;\n  // Are we even trying to save originals?\n  if (!self._savedOriginals)\n    return;\n  // Have we previously mutated the original (and so 'doc' is not actually\n  // original)?  (Note the 'has' check rather than truth: we store undefined\n  // here for inserted docs!)\n  if (self._savedOriginals.has(id))\n    return;\n  self._savedOriginals.set(id, EJSON.clone(doc));\n};\n\n// Pause the observers. No callbacks from observers will fire until\n// 'resumeObservers' is called.\nLocalCollection.prototype.pauseObservers = function () {\n  // No-op if already paused.\n  if (this.paused)\n    return;\n\n  // Set the 'paused' flag such that new observer messages don't fire.\n  this.paused = true;\n\n  // Take a snapshot of the query results for each query.\n  for (var qid in this.queries) {\n    var query = this.queries[qid];\n\n    query.resultsSnapshot = EJSON.clone(query.results);\n  }\n};\n\n// Resume the observers. Observers immediately receive change\n// notifications to bring them to the current state of the\n// database. Note that this is not just replaying all the changes that\n// happened during the pause, it is a smarter 'coalesced' diff.\nLocalCollection.prototype.resumeObservers = function () {\n  var self = this;\n  // No-op if not paused.\n  if (!this.paused)\n    return;\n\n  // Unset the 'paused' flag. Make sure to do this first, otherwise\n  // observer methods won't actually fire when we trigger them.\n  this.paused = false;\n\n  for (var qid in this.queries) {\n    var query = self.queries[qid];\n    if (query.dirty) {\n      query.dirty = false;\n      // re-compute results will perform `LocalCollection._diffQueryChanges` automatically.\n      self._recomputeResults(query, query.resultsSnapshot);\n    } else {\n      // Diff the current results against the snapshot and send to observers.\n      // pass the query object for its observer callbacks.\n      LocalCollection._diffQueryChanges(\n        query.ordered, query.resultsSnapshot, query.results, query,\n        {projectionFn: query.projectionFn});\n    }\n    query.resultsSnapshot = null;\n  }\n  self._observeQueue.drain();\n};\n"]},"hash":"1d7e9e9c1b57719f90bbf99b1367e5e1d223b8a2"}
